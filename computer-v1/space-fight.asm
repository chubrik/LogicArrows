OUT_NUM   equ 0x10  ; идентификатор цифрового дисплея
OUT_SCR   equ 0x80  ; идентификатор графического дисплея
CLEAR_TO  equ 0x58  ; граница между очищенной частью дисплея и заполненной врагами в начале игры
KEY_LEFT  equ 0x25  ; идентификатор клавиши "влево"
KEY_RIGHT equ 0x27  ; идентификатор клавиши "вправо"
KEY_FIRE  equ 0x20  ; идентификатор клавиши "пробел" (огонь)
STEP_CNT  equ 14    ; число ходов между сдвигами карты (с каждым разом на 2 хода меньше)
WIN_LEFT  equ 30    ; счёт врагов, оставшихся до победы

; очистка нижней части дисплея
CLEAR:
ldi c, 0x5C
ldi d, CLEAR_TO     ; верхняя граница очистки дисплея, а также для блока RND нижняя граница заполнения врагами
loop1:
  dec c
  st b, c
  mov a, c
  xor a, d
  jnz loop1

; заполнение дисплея случайно расположенными врагами
; в регистре D уже должен быть адрес нижней границы заполнения
RND:
ldi c, 0x40         ; адрес начала области дисплея как верхняя граница заполнения врагами
loop2:
  rnd a             ; работаем с байтом в правой части дисплея
  rnd b
  and a, b          ; совмещаем два случайных байта, чтобы для каждого бита получилась вероятность 25%
  shl a             ; отодвигаем биты от края дисплея, где невозможно произвести выстрел
  dec d
  st a, d
  rnd a             ; повторяем то же самое для левой части дисплея
  rnd b
  and a, b
  shr a
  dec d
  st a, d
  mov a, d
  xor a, c
  jnz loop2

; вывод счёта на цифровой дисплей
SCORE:
ld a, win_left      ; читаем счёт; при проигрыше игры эта команда будет перезаписана на hlt
ldi d, 0x40         ; адрес начала области дисплея, в т.ч. для блока WIN
ld b, d             ; запоминаем первый байт изображения на графическом дисплее
ldi c, OUT_NUM
st c, out           ; переключаем на цифровой дисплей
st a, d             ; выводим счёт
ldi c, OUT_SCR
st c, out           ; переключаем на графический дисплей
st b, d             ; восстанавливаем в памяти первый байт изображения
add a, 0            ; если счёт 0, то игра выиграна
jz WIN

; уменьшение значения оставшихся ходов
STEP:
ldi b, STEP2        ; адрес перехода к следующему шагу для блоков KEYS, LEFT, RIGHT
STEP2:
ld a, step_left
dec a
js LEVEL            ; если ходов не осталось, переходим к обновлению переменных и сдвигу карты
st a, step_left
jmp KEYS            ; прыжок в область памяти за графическим дисплеем

; заполнение пустым байтом, чтобы дальнейшие блоки заняли правильное место в памяти
filler1 db 0

; переменные
step_cnt db STEP_CNT  ; число ходов между сдвигами карты (с каждым разом на 2 хода меньше)
step_left db STEP_CNT ; оставшееся число ходов до ближайшего сдвига карты
win_left db WIN_LEFT  ; счёт врагов, оставшихся до победы

; порты
; расположены в зарезервированных адресах памяти
bank db 0           ; адрес 0x3D
in db 0             ; адрес 0x3E
out db OUT_SCR      ; адрес 0x3F

; начальная заставка игры
; расположена в зарезервированной области памяти с адресами 0x40...0x5F
start_image db 0b00101000, 0b00000000,
               0b00100000, 0b00101000,
               0b00000000, 0b00001000,
               0b00001001, 0b00000000,
               0b00100001, 0b00100000,
               0b00100011, 0b10001000,
               0b00000011, 0b10001000,
               0b00001011, 0b10100000,
               0b00001010, 0b10100000,
               0b00101110, 0b11101000,
               0b00101111, 0b11101000,
               0b00111011, 0b10111000,
               0b00110101, 0b01011000,
               0b00100000, 0b00001000,
               0b00000001, 0b00000000,
               0b00000011, 0b10000000

; определение нажатой клавиши
; в регистре B уже должен быть адрес для возврата к STEP2
KEYS:
mov a, 0
ld c, in            ; читаем код нажатой клавиши
st a, in            ; обнуляем значение в порту, чтобы определять повторные нажатия
ldi a, KEY_FIRE
xor a, c
jz FIRE
ldi a, KEY_RIGHT
xor a, c
jz RIGHT
ldi a, KEY_LEFT
xor a, c
jnz b               ; переходим к следующему ходу

; движение влево
; в регистре B уже должен быть адрес для возврата к STEP2
LEFT:
ld a, 0x5E          ; если мы у левого края, переходим к следующему ходу
shl a
jc b
ldi d, 0x5F         ; начало движения
ldi c, 4
loop3:
  ld a, d
  rcl a
  st a, d
  dec d
  dec c
  jnz loop3
jmp b               ; переходим к следующему ходу

; движение вправо
; в регистре B уже должен быть адрес для возврата к STEP2
RIGHT:
ld a, 0x5F          ; если мы у правого края, переходим к следующему ходу
shr a
jc b
ldi d, 0x5C         ; начало движения
ldi c, 4
loop4:
  ld a, d
  rcr a
  st a, d
  inc d
  dec c
  jnz loop4
jmp b               ; переходим к следующему ходу

; выстрел
FIRE:
ldi d, 0x5C         ; определяем стартовое положение снаряда
ld a, d
add a, 0
jnz shot
inc d
shot:               ; начало выстрела
  ld b, d
  ldi c, 14
loop5:              ; невидимый полёт снаряда
  dec d
  dec d
  ld a, d
  and a, b          ; если попали, выходим из цикла
  jnz hit
  dec c
  jnz loop5
jmp STEP            ; промах, переходим к следующему ходу
hit:                ; попадание, уменьшаем счёт врагов и переходим к следующему ходу
  ld a, d
  xor a, b
  st a, d
  ld a, win_left
  dec a
  st a, win_left
  jmp SCORE

; обновление переменных перед сдвигом карты
LEVEL:
ld a, step_cnt      ; уменьшаем на 2 число ходов до следующего сдвига карты
dec a
dec a
st a, step_cnt
st a, step_left
ldi c, 0x5A         ; нижняя граница сдвига карты для блока SCROLL
ld a, c
ld b, 0x5B
or a, b             ; если в третьем снизу ряду нет врагов, переходим к сдвигу карты
jz SCROLL
inc c               ; игра проиграна, смещаем нижнюю границу сдвига карты на один ряд ниже
inc c
ldi a, 0xEC         ; в блоке SCORE первую команду перезаписываем на hlt
st a, SCORE

; сдвиг карты
; в регистре C уже должен быть адрес нижней границы сдвига карты
SCROLL:
ldi d, 0x42         ; верхняя граница сдвига карты, а также для блока RND нижняя граница заполнения врагами
loop6:
  dec c
  mov a, c
  ld b, a
  inc a
  inc a
  st b, a
  xor a, d
  jnz loop6
jmp RND             ; переходим к генерации врагов в верхнем ряду, а затем к следующему шагу

; игра выиграна, вывод на дисплей финальной заставки-приза
; в регистре D уже должен быть адрес начала области дисплея
WIN:
ldi c, win_image
loop7:
  ld a, c
  st a, d
  inc d
  inc c             ; после 0xFF значение перейдёт в 0x00, что означает окончание вывода
  jnz loop7
hlt                 ; остановка программы

; заполнение пустыми байтами, чтобы финальная заставка-приз заняла правильное место в памяти
filler2 db 0, 0

; финальная заставка-приз
; расположена в области памяти с адресами 0xE0...0xFF
win_image db 0b00000000, 0b00000000,
             0b00000000, 0b00000000,
             0b00000011, 0b11000000,
             0b00000100, 0b00100000,
             0b00001001, 0b00010000,
             0b00010000, 0b00101000,
             0b00010100, 0b00001000,
             0b00100000, 0b10000100,
             0b00100000, 0b00000100,
             0b01000000, 0b00001010,
             0b01010011, 0b11000010,
             0b01000111, 0b11100010,
             0b01000111, 0b11100010,
             0b00110111, 0b11101100,
             0b00001111, 0b11110000,
             0b00000000, 0b00000000
