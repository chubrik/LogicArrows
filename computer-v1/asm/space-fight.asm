####################################################################################################
##           Source code for the "Space Fight!" game for a computer made of logic arrows          ##
##             Исходный код игры "Space Fight!" для компьютера из логических стрелочек            ##
##                  https://github.com/chubrik/LogicArrows/tree/main/computer-v1                  ##
##                          (с) 2024 Arkadi Chubrik (arkadi@chubrik.org)                          ##
####################################################################################################



; Константы
WIN_LEFT    equ 30                      ; Количество врагов, которое необходимо сбить для победы
STEP_CNT    equ 14                      ; Количество доступных ходов на первом уровне
KEY_LEFT    equ 0x11                    ; Код клавиши "Влево"
KEY_RIGHT   equ 0x13                    ; Код клавиши "Вправо"
KEY_FIRE    equ 0x20                    ; Код клавиши "Пробел" (огонь)
OUT_BCD     equ 0x10                    ; Код для подключения цифрового индикатора
OUT_DISPLAY equ 0x80                    ; Код для подключения дисплея



; Очищаем нижнюю часть дисплея
clear:          ldi c, 0x5C
                ldi d, 0x58             ; Верхняя граница очистки дисплея, а также для блока
                                        ;   "random" нижняя граница заполнения врагами
clear_loop:     dec c
                st b, c
                mov a, c
                xor a, d
                jnz clear_loop

; Заполняем дисплей случайно расположенными врагами.
; Регистр D уже содержит указатель на дисплее на нижнюю границу заполнения.
random:         ldi c, display          ; Адрес начала области дисплея как верхняя граница
                                        ;   заполнения врагами

random_loop:    rnd a                   ; Работаем с байтом в правой части дисплея
                rnd b
                and a, b                ; Совмещаем два случайных байта, чтобы для каждого бита
                                        ;   получилась вероятность 25%
                shl a                   ; Отодвигаем биты от края дисплея, где невозможно произвести
                                        ;   выстрел
                dec d
                st a, d
                rnd a                   ; Повторяем то же самое для левой части дисплея
                rnd b
                and a, b
                shr a
                dec d
                st a, d
                mov a, d
                xor a, c
                jnz random_loop

; Выводим счётчик врагов на цифровой индикатор
score:          ld a, win_left          ; Читаем счётчик врагов. При проигрыше игры эта команда
                                        ;   будет перезаписана на "hlt".
                ldi d, display          ; Адрес начала области дисплея, в т.ч. для блока "win"
                ld b, d                 ; Запоминаем первый байт изображения на дисплее
                ldi c, OUT_BCD
                st c, out               ; Переключаем вывод на цифровой индикатор
                st a, d                 ; Выводим значение счётчика врагов
                ldi c, OUT_DISPLAY
                st c, out               ; Переключаем вывод на дисплей
                st b, d                 ; Восстанавливаем в памяти первый байт изображения
                add a, 0                ; Если счётчик врагов равен нулю, то игра выиграна
                jz win

; Уменьшаем счётчик ходов
step:           ldi b, step2            ; Ссылка для перехода к следующему шагу для блоков "keys",
                                        ;   "left", "right"
step2:          ld a, step_left
                dec a
                js level                ; Если ходов не осталось, переходим на следующий уровень
                st a, step_left
                jmp keys                ; Перепрыгиваем через зарезервированную область памяти

void1       db  0

; Переменные и порты

step_cnt    db  STEP_CNT                ; Количество доступных ходов на текущем уровне
step_left   db  STEP_CNT                ; Счётчик оставшихся ходов на текущем уровне
win_left    db  WIN_LEFT                ; Счётчик врагов, оставшихся до победы
bank        db  0                       ; Порт банка памяти (не используется)
in          db  0                       ; Порт ввода
out         db  OUT_DISPLAY             ; Порт вывода, подключён дисплей

; Область дисплея 0x40...0x5F содержит заставку, отображаемую во время загрузки программы
display     db  0b00101000, 0b00000000, ;     ██  ██                       ;
                0b00100000, 0b00101000, ;     ██              ██  ██       ;
                0b00000000, 0b00001000, ;                         ██       ;
                0b00001001, 0b00000000, ;         ██    ██                 ;
                0b00100001, 0b00100000, ;     ██        ██    ██           ;
                0b00100011, 0b10001000, ;     ██      ██████      ██       ;
                0b00000011, 0b10001000, ;             ██████      ██       ;
                0b00001011, 0b10100000, ;         ██  ██████  ██           ;
                0b00001010, 0b10100000, ;         ██  ██  ██  ██           ;
                0b00101110, 0b11101000, ;     ██  ██████  ██████  ██       ;
                0b00101111, 0b11101000, ;     ██  ██████████████  ██       ;
                0b00111011, 0b10111000, ;     ██████  ██████  ██████       ;
                0b00110101, 0b01011000, ;     ████  ██  ██  ██  ████       ;
                0b00100000, 0b00001000, ;     ██                  ██       ;
                0b00000001, 0b00000000, ;               ██                 ;
                0b00000011, 0b10000000  ;             ██████               ;

; Опрашиваем клавиатуру на нажатие одной из управляющих клавиш.
; Регистр B уже содержит ссылку для возврата к step2.
keys:           mov a, 0
                ld c, in                ; Читаем код нажатой клавиши
                st a, in                ; Обнуляем значение в порту, чтобы определять повторные
                                        ;    нажатия
                ldi a, KEY_FIRE
                xor a, c
                jz fire
                ldi a, KEY_RIGHT
                xor a, c
                jz right
                ldi a, KEY_LEFT
                xor a, c
                jnz b                   ; Переходим к следующему ходу

; Сдвигаем корабль влево.
; Регистр B уже содержит ссылку для возврата к step2.
left:           ld a, 0x5E              ; Если мы у левого края, переходим к следующему ходу
                shl a
                jc b
                ldi d, 0x5F
                ldi c, 4

left_loop:      ld a, d
                rcl a
                st a, d
                dec d
                dec c
                jnz left_loop

                jmp b                   ; Переходим к следующему ходу

; Сдвигаем корабль вправо.
; Регистр B уже содержит ссылку для возврата к step2.
right:          ld a, 0x5F              ; Если мы у правого края, переходим к следующему ходу
                shr a
                jc b
                ldi d, 0x5C
                ldi c, 4

right_loop:     ld a, d
                rcr a
                st a, d
                inc d
                dec c
                jnz right_loop

                jmp b                   ; Переходим к следующему ходу

; Производим выстрел
fire:           ldi d, 0x5C             ; Определяем стартовое положение снаряда
                ld a, d
                add a, 0
                jnz fire_shot
                inc d

fire_shot:      ld b, d
                ldi c, 14

; Невидимый полёт снаряда
fire_loop:      dec d
                dec d
                ld a, d
                and a, b                ; Если попали, выходим из цикла
                jnz fire_hit
                dec c
                jnz fire_loop

                jmp step                ; Промах, переходим к следующему ходу

; Попадание. Убираем врага с дисплея, уменьшаем счётчик врагов и переходим к следующему ходу.
fire_hit:       ld a, d
                xor a, b
                st a, d
                ld a, win_left
                dec a
                st a, win_left
                jmp score

; Переходим на следующий уровень.
; Здесь враги станут ближе к нам, а число доступных ходов уменьшится.
level:          ld a, step_cnt          ; Уменьшаем число доступных ходов на два
                dec a
                dec a
                st a, step_cnt
                st a, step_left
                ldi c, 0x5A             ; Нижняя граница сдвига карты для блока "scroll"
                ld a, c
                ld b, 0x5B
                or a, b                 ; Если в третьем снизу ряду нет врагов, переходим к сдвигу
                                        ;   карты
                jz scroll
                inc c                   ; Игра проиграна, смещаем нижнюю границу сдвига карты на
                                        ;   один ряд ниже
                inc c
                ldi a, 0xEC             ; В блоке "score" первую команду перезаписываем на "hlt"
                st a, score

; Сдвигаем всех врагов ближе к нам.
; Регистр C уже содержит указатель на нижнюю границу для сдвига карты.
scroll:         ldi d, 0x42             ; Верхняя граница сдвига карты, а также для блока "random"
                                        ;   нижняя граница заполнения врагами
scroll_loop:    dec c
                mov a, c
                ld b, a
                inc a
                inc a
                st b, a
                xor a, d
                jnz scroll_loop

                jmp random              ; Переходим к генерации врагов в верхнем ряду, а затем к
                                        ;   следующему шагу

; Мы выиграли! Выводим на дисплей заставку-приз и завершаем выполнение программы.
; Регистр D уже содержит указатель на начало области дисплея.
win:            ldi c, prize

win_loop:       ld a, c
                st a, d
                inc d
                inc c                   ; После 0xFF значение перейдёт в 0x00, что означает
                                        ;   окончание вывода
                jnz win_loop

                hlt                     ; Остановка программы

void2       db  0, 0

; Область 0xE0...0xFF содержит заставку-приз для победителя
prize       db  0b00000000, 0b00000000,
                0b00000000, 0b00000000,
                0b00000011, 0b11000000,
                0b00000100, 0b00100000,
                0b00001001, 0b00010000,
                0b00010000, 0b00101000,
                0b00010100, 0b00001000,
                0b00100000, 0b10000100,
                0b00100000, 0b00000100,
                0b01000000, 0b00001010,
                0b01010011, 0b11000010,
                0b01000111, 0b11100010,
                0b01000111, 0b11100010,
                0b00110111, 0b11101100,
                0b00001111, 0b11110000,
                0b00000000, 0b00000000
